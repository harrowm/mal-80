#!/usr/bin/env python3
"""
TRS-80 Character ROM Extractor / Generator
============================================================================

IMPORTANT: The TRS-80 Model I character generator is a separate ROM chip
(MCM6670P) on the motherboard.  It is NOT embedded inside the Level I or
Level II BASIC ROMs.  If you pass a BASIC ROM to this script it will NOT
find valid character data.

Supported inputs:
  1. A standalone character generator ROM dump (512 or 1024 bytes)
     e.g.  trs80_chargen.bin, chargen.rom
  2. --builtin   Use the well-known TRS-80 Model I character set that is
                 already compiled into CharRom.hpp (useful for regeneration)

Usage examples:
    python3 extract_char_rom.py chargen.rom
    python3 extract_char_rom.py chargen.rom --preview
    python3 extract_char_rom.py --builtin --preview
"""

import argparse
import os
import sys
from pathlib import Path

# ============================================================================
# CONFIGURATION
# ============================================================================

CHAR_COUNT = 128
BYTES_PER_CHAR = 8
TOTAL_CHAR_BYTES = CHAR_COUNT * BYTES_PER_CHAR  # 1024 bytes

# ============================================================================
# BUILT-IN TRS-80 MODEL I CHARACTER ROM (MCM6670P)
# ============================================================================
# This is the same data that lives in src/video/CharRom.hpp.
# 128 characters x 8 bytes, 6-pixel wide glyphs, MSB-first.
# 0x00-0x1F: graphics/blank,  0x20-0x5F: ASCII,  0x60-0x7F: mirror of 0x40-0x5F
# ============================================================================

BUILTIN_CHARGEN = bytes([
    # 0x00-0x1B: blank
    *([0]*8*28),
    # 0x1C up-arrow
    0x08,0x1C,0x3E,0x08,0x08,0x08,0x08,0x00,
    # 0x1D down-arrow
    0x08,0x08,0x08,0x08,0x3E,0x1C,0x08,0x00,
    # 0x1E right-arrow
    0x00,0x08,0x04,0x3E,0x04,0x08,0x00,0x00,
    # 0x1F left-arrow
    0x00,0x08,0x10,0x3E,0x10,0x08,0x00,0x00,
    # 0x20 space
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    # 0x21 !
    0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x00,
    # 0x22 "
    0x14,0x14,0x14,0x00,0x00,0x00,0x00,0x00,
    # 0x23 #
    0x14,0x14,0x3E,0x14,0x3E,0x14,0x14,0x00,
    # 0x24 $
    0x08,0x1E,0x28,0x1C,0x0A,0x3C,0x08,0x00,
    # 0x25 %
    0x30,0x32,0x04,0x08,0x10,0x26,0x06,0x00,
    # 0x26 &
    0x10,0x28,0x28,0x10,0x2A,0x24,0x1A,0x00,
    # 0x27 '
    0x08,0x08,0x10,0x00,0x00,0x00,0x00,0x00,
    # 0x28 (
    0x04,0x08,0x10,0x10,0x10,0x08,0x04,0x00,
    # 0x29 )
    0x10,0x08,0x04,0x04,0x04,0x08,0x10,0x00,
    # 0x2A *
    0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00,
    # 0x2B +
    0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00,
    # 0x2C ,
    0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x10,
    # 0x2D -
    0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,
    # 0x2E .
    0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
    # 0x2F /
    0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00,
    # 0x30 0
    0x1C,0x22,0x26,0x2A,0x32,0x22,0x1C,0x00,
    # 0x31 1
    0x08,0x18,0x08,0x08,0x08,0x08,0x1C,0x00,
    # 0x32 2
    0x1C,0x22,0x02,0x0C,0x10,0x20,0x3E,0x00,
    # 0x33 3
    0x3E,0x02,0x04,0x0C,0x02,0x22,0x1C,0x00,
    # 0x34 4
    0x04,0x0C,0x14,0x24,0x3E,0x04,0x04,0x00,
    # 0x35 5
    0x3E,0x20,0x3C,0x02,0x02,0x22,0x1C,0x00,
    # 0x36 6
    0x0C,0x10,0x20,0x3C,0x22,0x22,0x1C,0x00,
    # 0x37 7
    0x3E,0x02,0x04,0x08,0x10,0x10,0x10,0x00,
    # 0x38 8
    0x1C,0x22,0x22,0x1C,0x22,0x22,0x1C,0x00,
    # 0x39 9
    0x1C,0x22,0x22,0x1E,0x02,0x04,0x18,0x00,
    # 0x3A :
    0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,
    # 0x3B ;
    0x00,0x00,0x08,0x00,0x00,0x08,0x08,0x10,
    # 0x3C <
    0x04,0x08,0x10,0x20,0x10,0x08,0x04,0x00,
    # 0x3D =
    0x00,0x00,0x3E,0x00,0x3E,0x00,0x00,0x00,
    # 0x3E >
    0x10,0x08,0x04,0x02,0x04,0x08,0x10,0x00,
    # 0x3F ?
    0x1C,0x22,0x02,0x04,0x08,0x00,0x08,0x00,
    # 0x40 @
    0x1C,0x22,0x2A,0x2E,0x2C,0x20,0x1E,0x00,
    # 0x41 A
    0x08,0x14,0x22,0x22,0x3E,0x22,0x22,0x00,
    # 0x42 B
    0x3C,0x22,0x22,0x3C,0x22,0x22,0x3C,0x00,
    # 0x43 C
    0x1C,0x22,0x20,0x20,0x20,0x22,0x1C,0x00,
    # 0x44 D
    0x38,0x24,0x22,0x22,0x22,0x24,0x38,0x00,
    # 0x45 E
    0x3E,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,
    # 0x46 F
    0x3E,0x20,0x20,0x3C,0x20,0x20,0x20,0x00,
    # 0x47 G
    0x1C,0x22,0x20,0x2E,0x22,0x22,0x1C,0x00,
    # 0x48 H
    0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x00,
    # 0x49 I
    0x1C,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,
    # 0x4A J
    0x02,0x02,0x02,0x02,0x02,0x22,0x1C,0x00,
    # 0x4B K
    0x22,0x24,0x28,0x30,0x28,0x24,0x22,0x00,
    # 0x4C L
    0x20,0x20,0x20,0x20,0x20,0x20,0x3E,0x00,
    # 0x4D M
    0x22,0x36,0x2A,0x2A,0x22,0x22,0x22,0x00,
    # 0x4E N
    0x22,0x32,0x2A,0x26,0x22,0x22,0x22,0x00,
    # 0x4F O
    0x1C,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,
    # 0x50 P
    0x3C,0x22,0x22,0x3C,0x20,0x20,0x20,0x00,
    # 0x51 Q
    0x1C,0x22,0x22,0x22,0x2A,0x24,0x1A,0x00,
    # 0x52 R
    0x3C,0x22,0x22,0x3C,0x28,0x24,0x22,0x00,
    # 0x53 S
    0x1C,0x22,0x20,0x1C,0x02,0x22,0x1C,0x00,
    # 0x54 T
    0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
    # 0x55 U
    0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,
    # 0x56 V
    0x22,0x22,0x22,0x22,0x14,0x14,0x08,0x00,
    # 0x57 W
    0x22,0x22,0x22,0x2A,0x2A,0x36,0x22,0x00,
    # 0x58 X
    0x22,0x22,0x14,0x08,0x14,0x22,0x22,0x00,
    # 0x59 Y
    0x22,0x22,0x14,0x08,0x08,0x08,0x08,0x00,
    # 0x5A Z
    0x3E,0x02,0x04,0x08,0x10,0x20,0x3E,0x00,
    # 0x5B [
    0x1C,0x10,0x10,0x10,0x10,0x10,0x1C,0x00,
    # 0x5C backslash
    0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00,
    # 0x5D ]
    0x1C,0x04,0x04,0x04,0x04,0x04,0x1C,0x00,
    # 0x5E ^
    0x08,0x14,0x22,0x00,0x00,0x00,0x00,0x00,
    # 0x5F _
    0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,
    # 0x60-0x7E mirror of 0x40-0x5E (no lowercase on Model I)
    0x1C,0x22,0x2A,0x2E,0x2C,0x20,0x1E,0x00,
    0x08,0x14,0x22,0x22,0x3E,0x22,0x22,0x00,
    0x3C,0x22,0x22,0x3C,0x22,0x22,0x3C,0x00,
    0x1C,0x22,0x20,0x20,0x20,0x22,0x1C,0x00,
    0x38,0x24,0x22,0x22,0x22,0x24,0x38,0x00,
    0x3E,0x20,0x20,0x3C,0x20,0x20,0x3E,0x00,
    0x3E,0x20,0x20,0x3C,0x20,0x20,0x20,0x00,
    0x1C,0x22,0x20,0x2E,0x22,0x22,0x1C,0x00,
    0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x00,
    0x1C,0x08,0x08,0x08,0x08,0x08,0x1C,0x00,
    0x02,0x02,0x02,0x02,0x02,0x22,0x1C,0x00,
    0x22,0x24,0x28,0x30,0x28,0x24,0x22,0x00,
    0x20,0x20,0x20,0x20,0x20,0x20,0x3E,0x00,
    0x22,0x36,0x2A,0x2A,0x22,0x22,0x22,0x00,
    0x22,0x32,0x2A,0x26,0x22,0x22,0x22,0x00,
    0x1C,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,
    0x3C,0x22,0x22,0x3C,0x20,0x20,0x20,0x00,
    0x1C,0x22,0x22,0x22,0x2A,0x24,0x1A,0x00,
    0x3C,0x22,0x22,0x3C,0x28,0x24,0x22,0x00,
    0x1C,0x22,0x20,0x1C,0x02,0x22,0x1C,0x00,
    0x3E,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
    0x22,0x22,0x22,0x22,0x22,0x22,0x1C,0x00,
    0x22,0x22,0x22,0x22,0x14,0x14,0x08,0x00,
    0x22,0x22,0x22,0x2A,0x2A,0x36,0x22,0x00,
    0x22,0x22,0x14,0x08,0x14,0x22,0x22,0x00,
    0x22,0x22,0x14,0x08,0x08,0x08,0x08,0x00,
    0x3E,0x02,0x04,0x08,0x10,0x20,0x3E,0x00,
    0x1C,0x10,0x10,0x10,0x10,0x10,0x1C,0x00,
    0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00,
    0x1C,0x04,0x04,0x04,0x04,0x04,0x1C,0x00,
    0x08,0x14,0x22,0x00,0x00,0x00,0x00,0x00,
    # 0x7F block cursor
    0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x00,
])

assert len(BUILTIN_CHARGEN) == TOTAL_CHAR_BYTES, \
    f"Built-in chargen is {len(BUILTIN_CHARGEN)} bytes, expected {TOTAL_CHAR_BYTES}"


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def read_chargen_file(path: str) -> bytes:
    """Read a standalone character generator ROM file."""
    if not os.path.exists(path):
        raise FileNotFoundError(f"File not found: {path}")

    with open(path, 'rb') as f:
        data = f.read()

    size = len(data)
    print(f"Loaded: {path} ({size} bytes)")

    # A standalone chargen ROM is typically 512 bytes (64 chars)
    # or 1024 bytes (128 chars).
    if size == 512:
        print("  512-byte ROM (64 characters) — will mirror upper 64 from lower")
        # Duplicate the 64 chars into the upper half (Model I has no lowercase)
        data = data + data
    elif size == 1024:
        print("  1024-byte ROM (128 characters)")
    elif 0x2000 <= size <= 0x4000:
        print(f"\n*** WARNING ***")
        print(f"  This looks like a BASIC ROM ({size} bytes), not a character")
        print(f"  generator ROM.  The TRS-80 Model I character generator is a")
        print(f"  SEPARATE chip (MCM6670P).  It is NOT inside the BASIC ROM.")
        print(f"  You need a standalone chargen dump (512 or 1024 bytes).")
        print(f"  Use --builtin to generate from the known character set.\n")
        raise ValueError("Input appears to be a BASIC ROM, not a character generator ROM")
    else:
        print(f"  Unusual size ({size} bytes) — treating as raw character data")
        if size < 512:
            raise ValueError(f"File too small ({size} bytes); need at least 512")
        data = data[:1024].ljust(1024, b'\x00')

    return data


def validate_chargen(data: bytes) -> bool:
    """Quick sanity check: are printable characters plausible?"""
    ok = 0
    total = 0
    for code in range(0x20, 0x60):
        total += 1
        offset = code * BYTES_PER_CHAR
        block = data[offset:offset + BYTES_PER_CHAR]
        # Bytes should be <= 0x3F (6-bit wide glyphs) and have some nonzero rows
        if all(b <= 0x7F for b in block) and any(b != 0 for b in block[:7]):
            ok += 1
    pct = 100 * ok // total
    if pct >= 80:
        print(f"  Validation: {ok}/{total} printable chars look valid ({pct}%)")
        return True
    else:
        print(f"  Validation: only {ok}/{total} printable chars look valid ({pct}%)")
        return False


def print_char_preview(data: bytes, codes=None):
    """Render selected characters as ASCII art."""
    if codes is None:
        codes = [0x20, 0x30, 0x31, 0x41, 0x42, 0x43, 0x48, 0x4F, 0x5A, 0x40, 0x7F]

    print("\nCharacter Preview")
    print("=" * 50)

    for code in codes:
        if code >= CHAR_COUNT:
            continue
        offset = code * BYTES_PER_CHAR
        pattern = data[offset:offset + BYTES_PER_CHAR]

        if 0x20 <= code < 0x7F:
            label = chr(code)
        else:
            label = f"0x{code:02X}"

        print(f"\n  Char 0x{code:02X} '{label}':")
        for row in range(7):
            byte = pattern[row]
            line = ''
            for bit in range(5, -1, -1):
                line += '██' if (byte >> bit) & 1 else '  '
            print(f"    {line}")


def generate_cpp_header(data: bytes, output_path: str):
    """Generate C++ header file with character ROM data."""
    lines = [
        '// ============================================================================',
        '// TRS-80 Model I Character Generator ROM',
        '// ============================================================================',
        '//',
        '// The TRS-80 Model I uses a separate character generator ROM chip (MCM6670P)',
        '// that is NOT part of the Level I or Level II BASIC ROMs.',
        '//',
        '// 128 characters x 8 bytes each = 1024 bytes',
        '// Each byte = one row of a 6-wide dot matrix (bits 5..0, MSB first)',
        '//',
        '// Generated by extract_char_rom.py',
        '// ============================================================================',
        '',
        '#pragma once',
        '#include <cstdint>',
        '',
        f'constexpr uint16_t TRS80_CHAR_COUNT = {CHAR_COUNT};',
        f'constexpr uint16_t TRS80_CHAR_BYTES_PER_CHAR = {BYTES_PER_CHAR};',
        f'constexpr uint16_t TRS80_CHAR_GEN_SIZE = {TOTAL_CHAR_BYTES};',
        '',
        '// Character Generator ROM Data (MCM6670P compatible)',
        'constexpr uint8_t TRS80_CHAR_GEN[TRS80_CHAR_GEN_SIZE] = {',
    ]

    for code in range(CHAR_COUNT):
        offset = code * BYTES_PER_CHAR
        block = data[offset:offset + BYTES_PER_CHAR]
        hex_vals = ', '.join(f'0x{b:02X}' for b in block)

        if 0x20 <= code < 0x7F:
            label = chr(code)
        else:
            label = f"0x{code:02X}"

        if code % 16 == 0:
            lines.append(f'\n    // ---- 0x{code:02X} - 0x{min(code+15, 0x7F):02X} ----')

        lines.append(f'    {hex_vals},  // 0x{code:02X} {label}')

    lines.append('};')
    lines.append('')
    lines.append('// Helper: get pattern byte for a character code and row')
    lines.append('inline uint8_t TRS80_GetCharPattern(uint8_t char_code, uint8_t row) {')
    lines.append('    if (char_code >= TRS80_CHAR_COUNT || row >= TRS80_CHAR_BYTES_PER_CHAR) {')
    lines.append('        return 0x00;')
    lines.append('    }')
    lines.append('    return TRS80_CHAR_GEN[char_code * TRS80_CHAR_BYTES_PER_CHAR + row];')
    lines.append('}')
    lines.append('')

    out_dir = os.path.dirname(output_path)
    if out_dir and not os.path.exists(out_dir):
        os.makedirs(out_dir)

    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))

    print(f"\nWrote C++ header: {output_path} ({os.path.getsize(output_path)} bytes)")


# ============================================================================
# MAIN
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='Extract or generate TRS-80 character ROM for Mal-80 emulator',
        epilog='NOTE: The character generator is a separate chip (MCM6670P), '
               'NOT part of the Level I/II BASIC ROMs.',
    )
    parser.add_argument(
        'rom_file', nargs='?', default=None,
        help='Path to standalone chargen ROM (512 or 1024 bytes)',
    )
    parser.add_argument(
        '--builtin', '-b', action='store_true',
        help='Use the built-in TRS-80 Model I character set',
    )
    parser.add_argument(
        '--output', '-o', default='src/video/CharRom.hpp',
        help='Output C++ header (default: src/video/CharRom.hpp)',
    )
    parser.add_argument(
        '--preview', '-p', action='store_true',
        help='Show ASCII-art preview of characters',
    )
    args = parser.parse_args()

    print('=' * 60)
    print('TRS-80 Character ROM Extractor')
    print('=' * 60)

    if args.builtin:
        print('\nUsing built-in TRS-80 Model I character set')
        char_data = BUILTIN_CHARGEN
    elif args.rom_file:
        char_data = read_chargen_file(args.rom_file)
    else:
        parser.print_help()
        print('\nError: provide a chargen ROM file or use --builtin')
        sys.exit(1)

    if not validate_chargen(char_data):
        print('\n*** Character data looks suspect — continuing anyway ***')

    if args.preview:
        print_char_preview(char_data)

    generate_cpp_header(char_data, args.output)

    print('\n' + '=' * 60)
    print('Done!')
    print('=' * 60)


if __name__ == '__main__':
    main()
